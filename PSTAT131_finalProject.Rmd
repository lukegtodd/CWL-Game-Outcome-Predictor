---
title: "PSTAT 131 Final Project"
author: "Luke Todd"
date: "4/4/2022"
output: 
  html_document:
   code_folding: hide
---

```{r setup, include=FALSE, message = FALSE}

knitr::opts_chunk$set(echo = TRUE)

library(vembedr)

```

# Introduction

The purpose of the project is to provide an easy, consumable form of skill rating for professional Call of Duty players. This could be used as a descriptive statistic, but it can also be used to guess the winner of the largest tournament of the year, Call of Duty Champs.

--- 

# What is the Call of Duty World League?

Call of Duty is a first-person shooter that first began in 2003. Since then, it has become one of the largest multiplayer video game franchises to exist. During this time, a competitive scene for the game has gained traction. In 2016, the Call of Duty World League was born -- a sponsored league that hosts major tournaments throughout the year for the best players in the world to play in. In these events, these pros play three different game modes to decide the winner of a series. These game modes are Hardpoint, Search and Destroy, and then a third game mode that often changes yearly. For the data that we are covering, the third game mode is Control. All of the teams in the league consist of 5 players, and the series are Best of 5's.

```{r}
embed_url("https://www.youtube.com/watch?v=VQC0aZuGBFs&t=2740s")
```

---  

# Game Modes in Circuit

### Hardpoint
In Hardpoint, the two teams must fight over a point on the map where every second they spend in this point, they gain one point. This point is called the "hardpoint." If two teams are in the hardpoint at the same time, then neither teams collects points. Every sixty seconds, the hardpoint changes locations on the map, so teams must make tactical decisions to be able to rotate across the map. The first team to 250 points wins the map.

```{r}
embed_url("https://www.youtube.com/watch?v=VQC0aZuGBFs&t=2740s") %>%
  use_start_time(6*60 + 35)
```

### Search and Destroy
In Search and Destroy, the two teams play rounds where each player only has one life; if you die, you are dead until the next round. The objective is to either kill the entire other team before the time limit, or if you are on offense, then you can plant the bomb. If the bomb detonates after 45 seconds, then you also win the round. The first team to win 6 rounds wins the map.

```{r}
embed_url("https://www.youtube.com/watch?v=VQC0aZuGBFs&t=2740s") %>%
  use_start_time(18*60 + 39)
```

### Control 
In Control, there is an offense team and a defense team. There are multiple rounds where each team switches off between offense and defense. Each team has 30 lives per round. The first time to win three rounds wins the map. The offensive team is trying to either capture two points on the map, or eliminate all 30 lives of the other team. The defensive team is trying to either defend the two points before the time rounds out, or eliminate all 30 lives of the other team. 

```{r}
embed_url("https://www.youtube.com/watch?v=VQC0aZuGBFs&t=2740s") %>%
  use_start_time(45*60 + 40)
```

---  

# Load Packages

```{r, include=FALSE, message = FALSE}

library(readr)
library(tidyverse)
library(tidymodels)
library(janitor)
library(sqldf)
library(sjmisc)
library(vembedr)

```

---  

# Load Data

This project makes use of official CWL data that is uploaded on Github. All data is organized relatively cleanly and all missing data is reported. 

```{r, error = FALSE, message = FALSE}

proleague2019 <- read_csv(url("https://raw.githubusercontent.com/Activision/cwl-data/master/data/data-2019-07-05-proleague.csv"))
fortworth2019 <- read_csv(url("https://raw.githubusercontent.com/Activision/cwl-data/master/data/data-2019-03-17-fortworth.csv"))
london2019 <- read_csv(url("https://raw.githubusercontent.com/Activision/cwl-data/master/data/data-2019-05-05-london.csv"))
anaheim2019 <- read_csv(url("https://raw.githubusercontent.com/Activision/cwl-data/master/data/data-2019-06-16-anaheim.csv"))
proleagueFinals2019 <- read_csv(url("https://raw.githubusercontent.com/Activision/cwl-data/master/data/data-2019-07-21-proleague-finals.csv"))

# all stats for all major tournaments (EXCEPT CHAMPS) in BO4 (2019)
majors2019 <- rbind(proleague2019, fortworth2019, london2019, anaheim2019, proleagueFinals2019)

# champs will act as our test data; we will try and predict the winner
champs2019 <- read_csv(url("https://raw.githubusercontent.com/Activision/cwl-data/master/data/data-2019-08-18-champs.csv"))

```

---  

# What data are we concerned with?

In order to assign an overall score to each individual player, we will need to address Hardpoint, Search and Destroy, and the Control separately. Once we have an individual score for each of the three game modes, we can use these to determine a final score.

**Hardpoint:**
1. player -- what player does the data correspond to  
2. mode -- game mode  
3. win -- 'W' or 'L'; use to find overall player win/loss ratio  
4. k_d -- kill/death ratio; used to show overall impact on the map  
5. assists -- in addition to k/d, assists show overall support on the map; higher assists can indicate better team work  
6. accuracy_percent -- player accuracy for each match  
7. damage_dealt -- total damage done in the map  
8. player_spm -- score per minute  
9. hill_time_s -- hill time measured in seconds  
10. hill_captures -- shows activity on the map (MIGHT INCLUDE)  
11. hill_defends -- shows activity on the map (MIGHT INCLUDE)  
12. match_id -- helpful for getting rid of missing data  

**Search and Destroy:**
1. player -- what player does the data correspond to  
2. mode -- game mode  
3. win -- 'W' or 'L'; use to find overall player win/loss ratio  
4. k_d -- kill/death ratio; used to show overall impact on the map  
5. assists -- in addition to k/d, assists show overall support on the map; higher assists can indicate better team work  
6. accuracy_percent -- player accuracy for each match  
7. damage_dealt -- total damage done in the map  
8. player_spm -- score per minute  
9. fb_round_ratio -- 'snd_firstbloods'/'snd_rounds' (NOT INCLUDED IN BASE DATA SET)  
10. bomb_sneak_defuses -- sneak defuses are often in pivotal rounds  
11. bomb_plants -- good indicator of role (MIGHT INCLUDE)  
12. bomb_defuses -- good indicator of role (MIGHT INCLUDE)  
13. match_id -- helpful for getting rid of missing data

**Control:**
1. player -- what player does the data correspond to  
2. mode -- game mode  
3. win -- 'W' or 'L'; use to find overall player win/loss ratio  
4. k_d -- kill/death ratio; used to show overall impact on the map  
5. assists -- in addition to k/d, assists show overall support on the map; higher assists can indicate better team work  
6. accuracy_percent -- player accuracy for each match  
7. damage_dealt -- total damage done in the map  
8. player_spm -- score per minute  
9. match_id -- helpful for getting rid of missing data  

---

# Data Split
In a typical data split, we would merge all the data into one large data set, and then split this set into 80% training and 20% test. However, for this project, we will use all major tournaments as the training data and then use COD Champs as the testing data. The data for all the majors consists of 12,630 observations. The data for COD Champs consists of 2,960 observations. This means that my 'split' is approximately a 81/19 split between train and test data.

---  

# Data Cleaning and Organization

The data below is for all of the majors throughout the season, except for COD Champs. We will reserve COD Champs to act as a test set. The raw data from each major is merged into one major dataset, further broken up into Hardpoint, SND, and Control datasets.  

### SEASON MAJORS 2019 DATA
```{r}

# CLEANING
majors2019 <- majors2019 %>% clean_names(.)

# new dataset that contains all of the missing data, just in case
majors2019_missing <- sqldf('SELECT * FROM majors2019 WHERE match_id LIKE "missing%"')

# whole event data, all players and all maps, where player names are organized alphabetically
majors2019 <- majors2019[order(majors2019$player),]

# removes missing values
majors2019 <- sqldf('SELECT * FROM majors2019 WHERE match_id NOT LIKE "missing%"')

# calculates all the players that have played more than 50 games
player_numgames <- count(majors2019, player) %>% subset(., n > 50) %>% remove_cols(n)

# includes all existing data for all players that have played more than 50 games (arbitrary number)
majors2019 <- sqldf('SELECT * FROM majors2019 WHERE player IN player_numgames')

# removes all matches where damage = 0; almost always occurs as a result of data loss
majors2019 <- sqldf('SELECT * FROM majors2019 WHERE damage_dealt != "0"')

# # converts win to numeric where 1 is Loss and 2 is Win
# majors2019$win <- factor(majors2019$win, levels = as.character(unique(majors2019$win)))
# majors2019$win <- as.numeric(majors2019$win)

```

**Hardpoint subset**
```{r}

# all 2019 hardpoint data
hp2019 <- sqldf('SELECT player, k_d, win, kills, deaths, x, assists, damage_dealt, player_spm, hill_time_s, hill_captures, hill_defends FROM majors2019 WHERE mode == "Hardpoint"')
hp2019 <- hp2019[order(hp2019$player),]

```

**Search and Destroy subset**
```{r}

# all 2019 SND data
snd2019 <- sqldf('SELECT player, win, k_d, assists, damage_dealt, player_spm, bomb_sneak_defuses, bomb_plants, bomb_defuses, snd_rounds, snd_firstbloods FROM majors2019 WHERE mode == "Search & Destroy"')

# adds new column with fb/round ratio
snd2019 <- add_column(snd2019, fb_round_ratio = snd2019$snd_firstbloods/snd2019$snd_rounds)

# adding a new column with average first bloods for the season
snd2019 <- snd2019 %>%
  group_by(player) %>%
  mutate(fb_avg = mean(snd_firstbloods))

# puts data in alphabetical order
snd2019 <- snd2019[order(snd2019$player),]

```

**Control subset**
```{r}

# all 2019 CONTROL data
control2019 <- sqldf('SELECT player, win, k_d, assists, damage_dealt, player_spm FROM majors2019 WHERE mode == "Control"')
control2019 <- control2019[order(control2019$player),]

```

### Cleaning Champs2019 dataset
```{r}

champs2019 <- champs2019 %>% clean_names(.)
champs2019 <- champs2019[order(champs2019$player),]
champs2019 <- sqldf('SELECT * FROM champs2019 WHERE match_id NOT LIKE "missing%"')
champs2019 <- sqldf('SELECT * FROM champs2019 WHERE damage_dealt != "0"')

```

**Hardpoint CHAMPS subset**
```{r}

# CHAMPS 2019 hardpoint data
hpChamps <- sqldf('SELECT player, k_d, win, kills, deaths, x, assists, damage_dealt, player_spm, hill_time_s, hill_captures, hill_defends FROM champs2019 WHERE mode == "Hardpoint"')
hpChamps <- hpChamps[order(hpChamps$player),]

```

**Search and Destroy CHAMPS subset**
```{r}

# CHAMPS 2019 SND data
sndChamps <- sqldf('SELECT player, win, k_d, assists, damage_dealt, player_spm, bomb_sneak_defuses, bomb_plants, bomb_defuses, snd_rounds, snd_firstbloods FROM champs2019 WHERE mode == "Search & Destroy"')

# adds new column with fb/round ratio
sndChamps <- add_column(sndChamps, fb_round_ratio = sndChamps$snd_firstbloods/sndChamps$snd_rounds)

# adding a new column with average first bloods for the season
sndChamps <- sndChamps %>%
  group_by(player) %>%
  mutate(fb_avg = mean(snd_firstbloods))

# puts data in alphabetical order
sndChamps <- sndChamps[order(sndChamps$player),]

```

**Control CHAMPS subset**
```{r}

# CHAMPS 2019 CONTROL data
controlChamps <- sqldf('SELECT player, win, k_d, assists, damage_dealt, player_spm FROM champs2019 WHERE mode == "Control"')
controlChamps <- controlChamps[order(controlChamps$player),]

```

---  

# Exploratory Data Analysis
For my exploratory data analysis, I will be using just the season data. It will not include the Champs data.

### Some basic plots: Kill/death for season
```{r, fig.height = 25, fig.width = 9}

ggplot(majors2019, aes(x = reorder(player, k_d), y = k_d)) + geom_boxplot() + coord_flip(ylim = c(0, 3.5)) + labs(y = "Kill/death ratio", x = "Player", subtitle = "OVERALL Player K/D's, 2019 Season (BO4), Descending")
ggplot(hp2019, aes(x = reorder(player, k_d), y = k_d)) + geom_boxplot() + coord_flip(ylim = c(0, 3.5)) + labs(y = "Kill/death ratio", x = "Player", subtitle = "Player K/D's for HARDPOINT, 2019 Season (BO4), Descending")
ggplot(snd2019, aes(x = reorder(player, k_d), y = k_d)) + geom_boxplot() + coord_flip(ylim = c(0, 5)) + labs(y = "Kill/death ratio", x = "Player", subtitle = "Player K/D's for SEARCH AND DESTROY, 2019 Season (BO4), Descending")
ggplot(control2019, aes(x = reorder(player, k_d), y = k_d)) + geom_boxplot() + coord_flip(ylim = c(0, 3.5)) + labs(y = "Kill/death ratio", x = "Player", subtitle = "Player K/D's for CONTROL, 2019 Season (BO4), Descending")

```

---

### Some basic plots: Search and Destroy First Bloods
Search and Destroy is a gamemode that has multiple rounds, where in each round, every player only has one life. A "first blood" is the first kill of the round and is usually highly influential. This a common stat that commentators and the community look at.

```{r, fig.height = 25, fig.width = 11}

# player firstblood average for SND 2019

ggplot(snd2019, aes(x = reorder(player, fb_avg), y = fb_avg)) + geom_point() + coord_flip(ylim = c(0, 3)) + labs(y = "Firstblood Average", x = "Player", subtitle = "Player Firstblood Average for SEARCH AND DESTROY, 2019 Season (BO4), Descending")

```


```{r, fig.height = 25, fig.width = 9}

# player firstbloods for SND 2019

ggplot(snd2019, aes(x = reorder(player, snd_firstbloods), y = snd_firstbloods)) + geom_boxplot() + coord_flip(ylim = c(0, 6)) + labs(y = "Firstbloods", x = "Player", subtitle = "Player Firstbloods for SEARCH AND DESTROY, 2019 Season (BO4), Descending")

```


```{r, fig.height = 25, fig.width = 11}

# player firstblood/round for SND 2019

ggplot(snd2019, aes(x = reorder(player, fb_round_ratio), y = fb_round_ratio)) + geom_boxplot() + coord_flip(ylim = c(0, 0.6)) + labs(y = "Firstblood/round ratio", x = "Player", subtitle = "Player Firstblood/Round for SEARCH AND DESTROY, 2019 Season (BO4), Descending")

```

### Some basic plots: Overall damage dealt

```{r, fig.height = 25, fig.width = 11}

# player damage dealt OVERALL 2019

# removes all entries where damage is 0; this is almost always a result of data loss
majors2019 <- sqldf('SELECT * FROM majors2019 WHERE damage_dealt != "0"')
playerDamage <- sqldf('SELECT player, damage_dealt FROM majors2019 WHERE damage_dealt != "0"')

ggplot(playerDamage, aes(x = reorder(player, damage_dealt), y = damage_dealt)) + geom_boxplot() + coord_flip(ylim = c(0, 10000)) + labs(y = "Damage Dealt", x = "Player", subtitle = "OVERALL Player Damage Dealt, 2019 Season (BO4), Descending")

```

### Some basic plots: Overall Score/Min (spm)

```{r, fig.height = 25, fig.width = 11}

# Overall score per minute for 2019 season

ggplot(majors2019, aes(x = reorder(player, player_spm), y = player_spm)) + geom_boxplot() + coord_flip(ylim = c(0, 675)) + labs(y = "Score per minute", x = "Player", subtitle = "OVERALL Player Score per minute, 2019 Season (BO4), Descending")

```

### Some basic plots: Number of wins

```{r, fig.height = 25, fig.width = 11}

# Overall number of wins for 2019 season

playerwins <- sqldf('SELECT player, win FROM majors2019 WHERE win == "W"') # selects all the wins for each player
playerwins <- playerwins %>% count(player) # counts the number of wins per player

ggplot(playerwins, aes(x = reorder(player, n), y = n)) + geom_bar(stat = 'identity') + coord_flip() + labs(y = "Number of Wins", x = "Player", subtitle = "OVERALL Number of Wins per Player, 2019 Season (BO4), Descending")

```

The top 4 players with the most amount of wins in the season are Slasher, Octane, Kenny, and Enable. The interesting part about this is that all of these players were on the same team, 100 Thieves. They all tied with 116 wins during the season. 


```{r}

playerwins %>%
  ggplot(aes(x = n)) + geom_histogram(binwidth = 15, color = "black", fill = "white")

```

The number of wins appears to follow a normal distribution. The left side of the histogram appears to be slightly more populated, but I hypothesize that this is due to players that didn't play for the whole season.







-----------------------------------------------------------------------------------------
**BREAK FROM EDA**






### Find correlation between variables
**I will begin by working with hardpoint data. In order to do this, I will need to compile each players' statistics into one column.** 

**I will be working with a new dataset, just so I don't mess up the original dataset.**
```{r}

hp2019_mb <- hp2019

```

**Number of wins for each player.**
```{r}

hp_playerwins <- sqldf('SELECT player, win FROM hp2019_mb WHERE win == "W"') # selects all the wins for each player
hp_playerwins <- hp_playerwins %>% count(player) # counts wins per players

```

**Attempting to use averages to predict win percentage of each player.**
```{r}

hp_player_numgames <- sqldf('SELECT player, win FROM hp2019_mb')
hp_player_numgames <- hp_player_numgames %>% count(player) # calculates the number of games played per player

hp_player_winrate <- merge(hp_playerwins, hp_player_numgames, by = c("player")) %>%
  mutate(winrate = n.x/n.y) %>%
  subset(., select = -c(n.x, n.y))

hp2019_averages <- hp2019_mb %>%
  group_by(player) %>%
  mutate(avg_kd = mean(k_d)) %>%
  mutate(avg_spm = mean(player_spm)) %>%
  mutate(avg_assists = mean(assists)) %>%
  mutate(avg_damagedealt = mean(damage_dealt)) %>%
  mutate(avg_hilltime = mean(hill_time_s)) %>%
  mutate(avg_captures = mean(hill_captures)) %>%
  mutate(avg_defends = mean(hill_defends)) %>%
  subset(., select = -c(kills, deaths, x, k_d, assists, damage_dealt, hill_time_s, hill_captures, hill_defends, player_spm, win)) %>%
  unique()

# creates a final dataset for hardpoint where each player only has one row, which includes the averages of all of his statistics
hp2019_averages <- merge(hp_player_winrate, hp2019_averages, by = c("player"))

```

**Attempting to use totals to predict number of wins of each player.**
```{r}

hp2019_totals <- hp2019_mb %>%
  group_by(player) %>%
  mutate(tot_kills = sum(kills)) %>%
  mutate(tot_deaths = sum(deaths)) %>%
  mutate(tot_x = sum(x)) %>%
  mutate(tot_spm = sum(player_spm)) %>%
  mutate(tot_assists = sum(assists)) %>%
  mutate(tot_damagedealt = sum(damage_dealt)) %>%
  mutate(tot_hilltime = sum(hill_time_s)) %>%
  mutate(tot_captures = sum(hill_captures)) %>%
  mutate(tot_defends = sum(hill_defends)) %>%
  subset(., select = -c(k_d, kills, deaths, x, assists, damage_dealt, hill_time_s, hill_captures, hill_defends, player_spm, win)) %>%
  unique()

# creates a final dataset for hardpoint where each player only has one row, which includes the averages of all of his statistics
hp2019_totals <- merge(hp_playerwins, hp2019_totals, by = c("player"))

```

### WORKING WITH AVERAGES / WIN RATE
**Correlation plots and matrix for AVERAGES**
```{r}

pairs(winrate ~ avg_kd + avg_spm + avg_damagedealt + avg_assists + avg_hilltime + avg_captures + avg_defends, data = hp2019_averages)

corr_averages_hp_2019 <- hp2019_averages %>%
  subset(., select = -c(player))

cor(corr_averages_hp_2019)

```

**Regression model for Hardpoint for AVERAGES**
```{r}

winrate <- lm(winrate ~ avg_kd + avg_spm + avg_assists + avg_damagedealt + avg_hilltime + avg_captures + avg_defends, data = hp2019_averages)
summary(wins)

```

**Relationship for AVERAGES**
```{r}

plot(hp2019_averages$winrate, hp2019_averages$avg_kd, xlab = "Win Rate", ylab = "Average K/D",
     title("Relationship between Win Rate and K/D"))

```


### WORKING WITH TOTALS / NUM OF WINS

**Correlation plots and matrix for TOTALS**
```{r}

# Equivalent with a formula
pairs(n ~ tot_kills + tot_deaths + tot_spm + tot_assists + tot_damagedealt + tot_hilltime + tot_captures + tot_defends, data = hp2019_totals)

corr_hp2019_totals <- hp2019_totals %>%
  subset(., select = -c(player))

cor(corr_hp2019_totals)

```

**Relationship for TOTALS**
```{r}

plot(hp2019_totals$n, hp2019_totals$tot_x, xlab = "Number of Wins", ylab = "Total Kills - Total Deaths",
     title("Relationship between Number of Wins and Kill and Death Discrepancy"))

```

**Regression model for Hardpoint for TOTALS**
```{r}

lm_totals <- lm(n ~ tot_kills + tot_deaths + tot_spm + tot_assists + tot_damagedealt + tot_hilltime + tot_captures + tot_defends, data = hp2019_totals)
summary(lm_totals)

```










-----------------------------------------------------------------------

ALL CODE WAS DONE USING GOOGLE / MY OWN

### MODEL 1: DECISION TREE ON MY OWN

**Now let's try a different approach, essentially from scratch. Let's try to predict a win (YES) or a loss (NO) using a player's data. DECISION TREE METHOD** Most likely, I should do this by gamemode. Otherwise, certain columns will be empty since some of the data is not releveant in different gamemodes.

```{r}
hp2019_wl <- hp2019

# changes W to 1, L to 0
# hp2019_wl$win <- ifelse(hp2019_wl$win == "W", 1, 0) %>%
#   as.factor()

hp2019_wl$win <- as.factor(hp2019_wl$win)

```

### SPLITTING DATA (in case I can't do it manually)

```{r}

hp2019_wlsplit <- hp2019_wl %>%
  initial_split(prop = 0.8, strata = "win")

hp2019_train <- training(hp2019_wlsplit)
hp2019_test <- testing(hp2019_wlsplit)

hp2019_train_folds <- vfold_cv(hp2019_train, v = 5, strata = win)

head(hp2019_train)

dim(hp2019_train)
dim(hp2019_test)

```


```{r}

prop.table(table(hp2019_train$win))

```

```{r}

# install.packages("rpart.plot")
library(rpart)
library(rpart.plot)

```


**Predicting with the test hardpoint data**
```{r}

fit_hp2019 <- rpart(win ~ k_d + assists + damage_dealt + player_spm + hill_time_s + hill_captures + hill_defends, data = hp2019_train, method = 'class')

rpart.plot(fit_hp2019, extra = 106)


predict_test <- predict(fit, hp2019_test, type = 'class')

table_mat <- table(hp2019_test$win, predict_test)
table_mat

accuracy_test <- sum(diag(table_mat)) / sum(table_mat)
print(paste('Accuracy for test:', accuracy_test))

```


**Testing further with Champs hardpoint data**
```{r}

fit_hpChamps <- rpart(win ~ k_d + assists + damage_dealt + player_spm + hill_time_s + hill_captures + hill_defends, data = hpChamps, method = 'class')

rpart.plot(fit_hpChamps, extra = 106)

predict_champs <- predict(fit_hpChamps, hpChamps, type = 'class')

table_mat <- table(hpChamps$win, predict_champs)
table_mat

accuracy_test <- sum(diag(table_mat)) / sum(table_mat)
print(paste('Accuracy for test:', accuracy_test))

```





-----------------------------------------------------------------------

BASING ALL FURTHER CODE ON HOMEWORK 6



### MODEL: Decision Tree Model

I will also be using a recipe, with split, stratified, and folded data. Similar to example project.


```{r}

recipe_hp <- recipe(win ~ k_d + assists + damage_dealt + player_spm + hill_time_s + hill_captures + hill_defends, data = hp2019_train) %>%
  step_dummy(all_nominal_predictors()) %>%
  step_normalize(all_predictors())

```

```{r}

library(rpart.plot)
library(vip)
library(janitor)
library(randomForest)
library(xgboost)

set.seed(3068)

tree_spec <- decision_tree() %>%
  set_engine("rpart")

class_tree_spec <- tree_spec %>%
  set_mode("classification")

class_tree_fit <- class_tree_spec %>%
  fit(win ~ k_d + assists + damage_dealt + player_spm + hill_time_s + hill_captures + hill_defends, data = hp2019_train)

class_tree_workflow <- workflow() %>%
  add_model(class_tree_spec %>% set_args(cost_complexity = tune())) %>%
  add_recipe(recipe_hp)

hp2019_folding <- vfold_cv(hp2019_train)

parameter_grid <- grid_regular(cost_complexity(range = c(-3, -1)), levels = 10)

tune_res <- tune_grid(class_tree_workflow, resamples = hp2019_folding, grid = parameter_grid, metrics = metric_set(roc_auc))

autoplot(tune_res)


```

```{r}

bestcomplexity <- select_best(tune_res, metric = "roc_auc")
bestcomplexity

```

```{r}

metrics <- collect_metrics(tune_res)
arrange(metrics, desc(mean))

```
We can see that our highest mean roc was about 76%.

```{r}

bestcomplexity <- select_best(tune_res)

class_tree_final <- finalize_workflow(class_tree_workflow, bestcomplexity)

class_tree_final_fit <- fit(class_tree_final, data = hp2019_train)

class_tree_final_fit %>%
  extract_fit_engine() %>%
  rpart.plot()

```

```{r}

roc <- select_best(tune_res, metric = "roc_auc")

decision_final <- finalize_workflow(class_tree_workflow, roc)

decision_fit <- fit(decision_final, data = hp2019_test)

```





--------------------------------------------

MODELS BASED ON THE FINAL PROJECT EXAMPLE

```{r}

train_folds <- vfold_cv(hp2019_train, v = 10, repeats = 5)

rf_model <- 
  rand_forest(
              min_n = tune(),
              mtry = tune(),
              mode = "regression") %>% 
  set_engine("ranger")

rf_workflow <- workflow() %>% 
  add_model(rf_model) %>% 
  add_recipe(recipe_hp)

```

```{r}

rf_params <- parameters(rf_model) %>% 
  update(mtry = mtry(range= c(2, 120)))

# define grid
rf_grid <- grid_regular(rf_params, levels = 2)

```

```{r}

rf_tune <- rf_workflow %>% 
  tune_grid(
    resamples = train_folds, 
    # how does it complete the models in those workflows
    grid = rf_grid)

```

```{r}

autoplot(rf_tune, metric = "rmse")

```




